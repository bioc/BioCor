---
title: "BioCor"
author: '[Lluís Revilla](mailto:lrevilla@clinic.cat)'
date: '`r date()`'
output:
  BiocStyle::pdf_document:
    fig_caption: yes
    toc: yes
  BiocStyle::html_document:
    fig_caption: yes
    toc_float: yes
package: '`r BiocStyle::pkg_ver("BioCor")`'
vignette: "%\\VignetteIndexEntry{BioCor} %\\VignetteEngine{knitr::rmarkdown} %\\VignetteEncoding{UTF-8}
  \ \n"
---
```{r knitsetup, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_knit$set(root.dir = ".")
knitr::opts_chunk$set(fig.width = 20, fig.height = 20, collapse = TRUE)
```


# Introduction

Functional similarities have already been used to several purposes, most of them are based on Gene Ontology, which can be calculated using [GOSemSim](https://bioconductor.org/packages/release/bioc/html/GOSemSim.html), or other controlled vocabulary.

General methods for similarity between to sets has been proposed Jaccard and Dice. However they have not been used to compare the similarity of pathways, or genes, neither between genes and pathways nor between databases. With this package we provide the methods to calculate such similarities with flexibility.

Here we provides functions to calculate similarities for pathways, genes and clusters of genes. As it development started aiming to group better genes by functionallity in co-expression networks using [WGCNA](https://cran.r-project.org/package=WGCNA).

# Citation
The main article describing how it has been applied, is currently under writing.

# Installation
The BioCor package will be available at bioconductor.org and will be downloaded and installed via biocLite:
```{r install, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("BioCor")
```

You can install the latest version with:
```{r github, eval = FALSE}
library("devtools")
install_github("llrs/BioCor")
```

# Using BioCor

## Preparation

We can load the package and prepare the data for which we want to calculate the similarities:
```{r load}
library("BioCor")
# Load libraries with the data of the pathways
library("org.Hs.eg.db")
library("reactome.db")
# Prepare the data
entrezids <- keys(org.Hs.eg.db, keytype = "ENTREZID")
genes.kegg <- select(org.Hs.eg.db, keys = entrezids, keytype = "ENTREZID", 
                     columns = "PATH")
genes.react <- select(reactome.db, keys = entrezids, keytype = "ENTREZID", 
                      columns = "REACTOMEID")
```

To avoid having biased data it is important to have all the data about the pathways and genes associated to all pathways for organism under study. Here we assume that we are interested in human pathways. We use this two databases KEGG and Reactome as they are easy to obtain the data. However KEGG database is no longer free for large retrievals therefore it is not longer updated in the Bioconductor annotation packages.


## Pathway similarities

We can compute similarities between two pathways or between several pathways and combine them, or not:
```{r pathSim}
pathways1 <- c("112310", "112315", "112316", "373753", "916853")
pathways2 <- c("109582", "114608", "1500931", "888590", "76002", "76005")
pathSim(pathways1[1], pathways2[3], genes.react, "ENTREZID", "REACTOMEID")
mpathSim(pathways1, pathways2, genes.react, "ENTREZID", "REACTOMEID", NULL)
```
In row-wise we have the pathways of the first argument and column-wise the pathways of the second argument.

### Combining values
To combine values we provide a function with several methods:
```{r combineScores}
sim <- mpathSim(pathways1, pathways2, genes.react, "ENTREZID", "REACTOMEID", NULL)
methodsCombineScores <- c("avg", "max", "rcmax", "rcmax.avg", "BMA")
sapply(methodsCombineScores, combineScores, scores = sim)
```
We can also specify the method to combine the similarities in mpathSim argument method, by default it is the "max" method.

## Gene similarities
To calculate a single pair of comparisons there are the `genesSim` and `mgeneSim` function for several comparisons. In this example we compare the genes BRCA1 and BRCA2 and NAT2:
```{r genesSim}
genesSim("672", "675", genes.kegg, "ENTREZID", "PATH")
genesSim("672", "675", genes.react, "ENTREZID", "REACTOMEID")

mgeneSim(c("672", "675", "10"), genes.kegg, "ENTREZID", "PATH")
mgeneSim(c("672", "675", "10"), genes.react, "ENTREZID", "REACTOMEID")
```

Note that for the same genes each database has different annotations, which result on different similarity scores. In this example the gene 18 has `r ncol(genesSim("672", "675", genes.kegg, "ENTREZID", "PATH", NULL))` and `r ncol(genesSim("672", "675", genes.react, "ENTREZID", "REACTOMEID", NULL))` pathways in KEGG and Reactome respectively and the gene 81 has `r nrow(genesSim("672", "675", genes.kegg, "ENTREZID", "PATH", NULL))` and `r nrow(genesSim("672", "675", genes.react, "ENTREZID", "REACTOMEID", NULL))` pathways in KEGG and Reactome respectively which results on different scores.

## Gene cluster similarities

There are two mehtods:
 - Combining all the pathways for each cluster and then compare between them
 - Calculate the similarity between the genes of a cluster and combine the similarities for each gene of a cluster
In the first case, if a method to combine pathways similarities is not provided are all returned:
```{r clusterSim}
clusterSim(c("672", "675"), c("100", "10", "1"), genes.kegg,
           "ENTREZID", "PATH")
clusterSim(c("672", "675"), c("100", "10", "1"), genes.kegg,
           "ENTREZID", "PATH", NULL)

clusters <- list(cluster1 = c("672", "675"),
                 cluster2 = c("100", "10", "1"),
                 cluster3 = c("18", "10", "83"))
mclusterSim(clusters, genes.kegg, "ENTREZID", "PATH", "rcmax.avg")
```
In the second case, we need to specify two methods to combine values, the first one to combine pathway similarities, the second to combine gene similarities. If only one is provided it returns the matrix of both similarities of the genes of each cluster:
```{r clustersSim}
clustersSim(c("672", "675"), c("100", "10", "1"), genes.kegg,
           "ENTREZID", "PATH")
clustersSim(c("672", "675"), c("100", "10", "1"), genes.kegg,
           "ENTREZID", "PATH", "max")

mclustersSim(clusters, genes.kegg, "ENTREZID", "PATH", c("max", "rcmax.avg"))
```

Note the differences between the values with each method for clusters similarity with the same information:
```{r clusters_methods}
mclusterSim(clusters, genes.kegg, "ENTREZID", "PATH", "rcmax.avg")
mclustersSim(clusters, genes.kegg, "ENTREZID", "PATH", c("max", "rcmax.avg"))
```

# High volumes of gene similarities
If we want multiple gene pair-wise comparisons we can use bioCor, which accepts a parallel back-end:
```{r big, collapse=TRUE}
genes.id <- c("10", "15", "16", "18", "2", "9", "52", "3855", "3880", "644", 
              "81327", "9128", "2073", "2893", "5142", "60", "210", "81", 
              "1352", "88")
library("BiocParallel")
sim <- bioCor(genes.id, all = TRUE, BPPARAM = MulticoreParam())
sim
```

Now in `sim` we have a list of matrices of `r nrow(sim[[1]])` rows and columns with similarities from both, Reatome and KEGG database.

# FAQ

## How do you calculate how similar two genes are ?
It uses the [Sørensen–Dice index](https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient): 
It is the top score of the doble of the genes shared by pathways of the two genes ($i$ and $j$) divided by the number of genes in each pathway.

We can calculate the similarity between two pathways ($x$, $w$) with:

$sim(x, w) = \frac{2 · |x \cap y|}{|x| + |y|}$

This is implemented in the `diceSim` function, which results is similar to Jaccard index:

$J(x, w) = \frac{|x \cap w|}{|x \cup w|}$

To calculate the Jaccard index use the `D2J` function.

The resulting values are $sim(x, w)  \in [0, 1]$. To calculate the similarity between two genes is implemented in the `genesSim` function.

## Why do you use the dice coefficient and not the Jaccard ?
We consider Dice coefficient better than Jaccard because it has higher values for the same comparisons. If in a database a gene is annotated to belong to a pathaway it has more meaning for the similarity than if it is not annotated. 

## How do you combine similarities between two genes with several pathways?
Although I recommend the "max" method (Which is the default) there are implemented others in the `combineScores` of the `GOSemSim` package which I borrowed.

## Why do you recommend using the max method to combine similarities scores for pathways?

The similarity is intended to calculate how much functionally related are two genes in the pathways where they are described. The higher the similarity is in a pathway, the higher they relate. A gene might be highly related to several genes but those relationships if important can be caught by other similarities scores or by experimental data like expression correlation of both genes.

## Why isn't available a method for calculating GO ?
This is covered by the GOSemSim package, you can use it to produce a similarity matrix (i.e. use `mgeneSim`). You can parallelize it with `foreach` package or `BiocParallel` if your list of genes is big. 

## How does bioCor deal when one gene is mapped to several ones?
It keeps the one with the higher mean similarity for all the genes available in the comparison. That means that for a different comparison depending on which genes you are computing a gene can have different values. 

## I get some criptic warnings, how do I solve them?

If you see some warnings like:
```{r, eval = FALSE}
In FUN(if (length(d.call) < 2L) newX[, 1] else array(newX[, 1L],  :
  no non-missing arguments to max; returning -Inf
In is.na(out) : is.na() applied to non-(list or vector) of type 'NULL'
```
And the resulting values are `NaN` check if you have selected the right column to extract the pathways from the data you provided.

# WGCNA and BioCor 

BioCor was originally thought to be used with other clustering packages using similarity measures like WGCNA, does. Here we provide an example on how to use BioCor with WGCNA, assuming we have already calculated the similarities in the `sim` matrix.

```{r wgcna, eval=FALSE}
# Load the expression data
load("expression.RData", verbose = TRUE)
expr.sim <- adjacency(expr) # set the power necessary for a scale free topology
# To combine the similarities we can use several functions:
similarity <- addSimilarities(expr.sim, sim, w = c(0.8, 0.1, 0.1))
# Equivalent to the previous one
similarity <- similarities(c(list(exp = expr.sim), sim), 
                           weighted.sum, w = c(0.8, 0.1, 0.1))
# Multiply each similarity to keep the sign if we use 
# adjacency type = "unsigned" for TOMType  = "signed"
similarity <- similarities(c(list(exp = expr.sim), sim), prod) 

# Once we have the similarities we can calculate the TOM with TOM
TOM <- TOMsimilarity(similarity)
dissTOM <- 1 - TOM
geneTree <- hclust(as.dist(dissTOM), method = "average")
# We can use the recomended way of WGCNA or any other clustering tool
dynamicMods <- cutreeHybrid(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = 30)
moduleColors <- labels2colors(dynamicMods$labels) 
```
Once identified the modules using the functional similarities of this package, one can continue with the workflow of WGCNA.

# Session Info

```{r session}
sessionInfo()
```
