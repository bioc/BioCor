---
title: "Advanced usage of BioCor"
abstract: >
  Describes how to use the BioCor package to answer several biological 
  questions and how to use functional similarities with other measures.
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('BioCor')`"
output:
  BiocStyle::html_document:
    fig_caption: true
    toc_float:
      collapsed: true
      toc_depth: 3
author:
- name: LluÃ­s Revilla
  affiliation: 
    - IDIBAPS; Liver Unit, Hospital Clinic; Universitat Pompeu Fabra
  email: lluis.revilla@gmail.com
vignette: >
  %\VignetteIndexEntry{Advanced usage of BioCor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---
```{r knitsetup, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_knit$set(root.dir = ".")
knitr::opts_chunk$set(collapse = TRUE, warning = TRUE, fig.wide = TRUE, cache = TRUE)
BiocStyle::markdown()
library("BiocStyle")
library("BioCor")
library("org.Hs.eg.db")
library("reactome.db")
unloadNamespace("GOSemSim")
genesKegg <- as.list(org.Hs.egPATH)
genesReact <- as.list(reactomeEXTID2PATHID)
# Remove genes and pathways which are not from human pathways 
genesReact <- sapply(genesReact, function(x){grep("R-HSA-", x, value = TRUE)}) 
genesReact <- genesReact[lengths(genesReact) >= 1] 
```

# Merging similarities {#merging}

If one calculates similarities with KEGG data and Reactome or other input for the same genes or clusters BioCor provides a couple of functions to merge them.

We can set a weight to each similarity input with `weighted.sum`, multiply them also using a weight for each similarity (with `weighted.prod`), doing the mean or just adding them up. Similarities allow us to apply a function to combine the matrices of a list. Here we use some of the genes used in the first vignette:
```{r merging}
kegg <- mgeneSim(c("672", "675", "10"), genesKegg)
react <- mgeneSim(c("672", "675", "10"), genesReact)
## We can sum it adding a weight to each origin
weighted.sum(c(kegg["672", "675"], react["672","675"]), w = c(0.3, 0.7))

## Or if we want to perform for all the matrix
## A list of matrices to merge
sim <- list("kegg" = kegg, "react" = react)
similarities(sim, weighted.sum, w = c(0.3, 0.7))
similarities(sim, weighted.prod, w = c(0.3, 0.7))
similarities(sim, prod)
similarities(sim, mean)
```
This functions are similar to `weighted.mean`, except that first the multiplication by the weights is done and then the `NA`s are removed:
```{r weighted}
weighted.mean(c(1, NA), w = c(0.5, 0.5), na.rm = TRUE)
weighted.mean(c(1, 0.5, NA), w = c(0.5, 0.25, 0.25), na.rm = TRUE)
weighted.sum(c(1, NA), w = c(0.5, 0.5))
weighted.sum(c(1, 0.5, NA), w = c(0.5, 0.25, 0.25))
weighted.prod(c(1, NA), w = c(0.5, 0.5))
weighted.prod(c(1, 0.5, NA), w = c(0.5, 0.25, 0.25))
```

# Assesing a differential study
In this example we will use the functional similarities in a classical differential study.

## Obtaining data
We start using data from the [RNAseq workflow](http://bioconductor.org/help/workflows/rnaseqGene/#differential-expression-analysis) and following the analysis:

```{r simulate, fig.cap="Volcano plot. The airway data", fig.wide = TRUE}
suppressPackageStartupMessages(library("airway"))
data("airway")
library("DESeq2")

dds <- DESeqDataSet(airway, design = ~ cell + dex)
dds$dex <- relevel(dds$dex, "untrt")
dds <- DESeq(dds)
res <- results(dds, alpha = 0.05)
summary(res)
plot(res$log2FoldChange, -log10(res$padj), pch = 16, xlab = "log2FC", 
     ylab = "-log10(p.ajd)", main = "Untreated vs treated")
logFC <- 2.5
abline(v=c(-logFC, logFC), h = -log10(0.05), col = "red")
```
As we can see here there are around 4000 genes differentially expressed genes

## Selecting differentially expressed genes

Usually in such a study one select a genes above a logFC or fold change threshold, here we use the absolute value of `r logFC`:
```{r BioCor}
fc <- res[abs(res$log2FoldChange) >= logFC & !is.na(res$padj), ]
fc <- fc[fc$padj < 0.05, ]
# Convert Ids
genes <- select(org.Hs.eg.db, keys = rownames(res), keytype = "ENSEMBL", 
                column = c("ENTREZID", "SYMBOL"))
genesFC <- genes[genes$ENSEMBL %in% rownames(fc),]
genesSim <- genesFC$ENTREZID
names(genesSim) <- genesFC$SYMBOL
genesSim <- genesSim[!duplicated(genesSim)]
# Calculate the functional similarity
sim <- mgeneSim(genes = genesSim, info = genesReact, method = "BMA")
```
Once we have calculated the similarity for the genes we can now visualize the effect of each method:
```{r pval1, fig.cap="Functional similarity of genes with logFC above 2.5. Similar genes cluster together as ADCY8 and ADC1.", fig.width=15, fig.height=20}
nas <- apply(sim, 1, function(x){all(is.na(x))})
sim <- sim[!nas, !nas]

MDSs <- cmdscale(1-sim)
plot(MDSs, type = "n", main = "BMA similarity", xlab = "MDS1", ylab = "MDS2")
text(MDSs, labels =  rownames(MDSs))
abline(h = 0, v = 0)
```

Note that here we are only using `r nrow(MDSs)` genes from the original `r nrow(fc)`.

## Are differentially expressed genes selected by their functionallity?

In the previous section we have seen that some genes are functionally related and that they have a high logFC value. Are genes differentially expressed more functional related than those which aren't differential expressed?
```{r setting, fig.cap="Volcano plot of the subset of 400 genes. This subset will be used in the following sections"} 
set.seed(250)
subRes <- res[!is.na(res$log2FoldChange), ]
subs <- sample.int(nrow(subRes), size = 400)
subRes <- subRes[subs, ]
plot(subRes$log2FoldChange, -log10(subRes$padj), pch = 16, xlab = "log2FC", 
     ylab = "-log10(p.ajd)", main = "Untreated vs treated")
abline(v=c(-logFC, logFC), h = -log10(0.05), col = "red")
g <- genes[genes$ENSEMBL %in% rownames(subRes), "ENTREZID"]
gS <- mgeneSim(g, genesReact, "BMA")
deg <- rownames(subRes[subRes$padj < 0.05 & !is.na(subRes$padj), ])
keep <- rownames(gS) %in% genes[genes$ENSEMBL %in% deg, "ENTREZID"]
```

We can answer this by testing it empirically:
```{r cluster2, fig.cap="Distribution of scores between differentially expressed genes and those who aren't. The line indicates the mean score of the similarity between differentially expressed genes and those which aren't differentially expressed.", fig.wide = TRUE}
library("boot")
# The mean of genes differentially expressed
(scoreB <- mean(gS[!keep, keep], na.rm = TRUE)) 
b <- boot(data = gS, R = 1000, statistic= function(x, i){
    g <- !rownames(x) %in% rownames(x)[i]
    mean(x[g, i], na.rm = TRUE)
})
(p.val <- (1 + sum(b$t>scoreB))/1001)
hist(b$t, main = "Distribution of scores", xlab = "Similarity score")
abline(v = scoreB, col = "red")
```
Comparing the genes differentially expressed and those who aren't doesn't show that they are non-randomly selected (p-value `r p.val`). The genes with a p-value below the threshold are not more closely functionally related than all the other genes[^1].

[^1]: From 400 genes there are `r nrow(gS)` with pathway information and only `r length(deg)` where significantly differentially expressed. Testing for the whole set of genes might yield different results.

## Are functionally related the selected differentially expressed genes?

We have seen that the genes differentially expressed aren't selected by their functionallity. But are they more functionally related than it would be expected ?

```{r pval2, fig.cap="Distribution of the similarity within differentially expressed genes. The line indicates the mean funtional similarity whitin them.", fig.wide = TRUE}
(scoreW <- combineScores(gS[keep, keep], "avg"))
b <- boot(data = gS, R = 1000, statistic= function(x, i){
    mean(x[i, i], na.rm = TRUE)
})
(p.val <- (1 + sum(b$t>scoreW))/1001) # P-value
hist(b$t, main = "Distribution of scores", xlab = "Similarity score")
abline(v = scoreW, col = "red")
```
We can see that we would expect a score around `r scoreW` if we selected randomly the genes from our pool with a probability of `r p.val`. That means that the differentially expressed genes is highly different compared to the other genes[^2].

[^2]: Remember that this is a small subset.

## Influence of the fold change in the funtionally similarity of the genes

We have seen that the genes differentially expressed are not selected by functional similarity but they are functionally related.  Now we would like to know if selecting a fold change threshold affects the functional similarity between them. 

To know the relationship between the fold change and the similarity between genes we have several methods:
```{r logfc1, fig.cap="Similarity of genes along abs(logFC). Assessing the similarity of genes according to their absolute log2 fold change. The red line indicates the fold change of the selected differentially expressed genes. The green line indicates the similarity score between ths selected ", fig.wide = TRUE}
s <- seq(0, max(abs(subRes$log2FoldChange))+0.05, by = 0.05)
l <- sapply(s, function(x){
    deg <- rownames(subRes[abs(subRes$log2FoldChange) >= x, ])
    keep <- rownames(gS) %in% genes[genes$ENSEMBL %in% deg, "ENTREZID"]
    BetweenAbove <- mean(gS[keep, keep], na.rm = TRUE)
    AboveBelow <- mean(gS[keep, !keep], na.rm = TRUE)
    c("BetweenAbove" = BetweenAbove, "AboveBelow" = AboveBelow)
})
L <- as.data.frame(cbind(logfc = s, t(l)))
plot(L$logfc, L$BetweenAbove, type = "l", xlab = "abs(log2) fold change", 
     ylab = "Similarity score", 
     main = "Similarity scores along logFC", col = "darkred")
lines(L$logfc, L$AboveBelow, col = "darkgreen")
abline(h = c(scoreB, scoreW), col = c("green", "red"))
legend("topleft", 
       legend = c("Between genes above and below threshold", 
                  "Whitin genes above threshold"), 
       fill = c("darkgreen", "darkred"))
```

The functional similarity of the genes above the threshold increase with a more restrictive threshold, indicating that a logFC threshold selects related genes by functionality. While the similarity between those genes above the threshold and below remains constant. The lines indicate that the differentially expressed genes  have a los log2 fold change.

```{r logfc2, fig.catp = "Functional similarity between the three classifications of genes according to fold change. The upr-r"}
s <- seq(0, max(subRes$log2FoldChange)+0.05, by = 0.05)
l <- sapply(s, function(x){
    degUp <- rownames(subRes[subRes$log2FoldChange >= x, ])
    degDown <- rownames(subRes[subRes$log2FoldChange <= -x, ])
    keepUp <- rownames(gS) %in% genes[genes$ENSEMBL %in% degUp, "ENTREZID"]
    keepDown <- rownames(gS) %in% genes[genes$ENSEMBL %in% degDown, "ENTREZID"]
    between <- mean(gS[keepUp, keepDown], na.rm = TRUE)
    downOthers <- mean(gS[keepDown, !(keepDown & keepUp)], na.rm = TRUE)
    upOthers <- mean(gS[keepUp, !(keepDown & keepUp)], na.rm = TRUE)
    c("UpVsDown" = between, "UpVsOthers" = upOthers, "DownVsOthers"= downOthers)
})
L <- as.data.frame(cbind("logfc" = s, t(l)))
plot(L$logfc, L$UpVsDown, type = "l", xlab = "abs(log2) fold change threshold", ylab = "Similarity score", 
     main = "Similarity scores along logFC")
lines(L$logfc, L$UpVsOthers, col = "red")
lines(L$logfc, L$DownVsOthers, col = "green")
legend("topright", legend = c("Up vs down regulated genes",
                              "Up-regulated vs not down-regulated genes",
                              "Down-regulated vs not up-regulated genes"),
       fill = c("black", "red", "green"))
```

The maximal functional similarity between genes up-regulated and down-regulated are at `r L[which.max(L$l), "logfc"]` log2 fold change.

# Assesing a new pathway

We can test how does the network of genes change if we add a new pathway, for instance we have a new pathway with the genes of deg:

```{r newPathway, fig.wide = TRUE, eval = FALSE}
# Adding a new pathway "deg" to those genes
genesReact2 <- genesReact
diffGenes <- genes[genes$ENSEMBL %in% deg, "ENTREZID"]
genesReact2[diffGenes] <- sapply(genesReact[diffGenes], function(x){c(x, "deg")})
plot(ecdf(mgeneSim(names(genesReact), genesReact)))
curve(ecdf(mgeneSim(names(genesReact2), genesReact2)), color = "red")
```
This would take lot of time, for a ilustration purpose we reduce to some genes:

```{r newPathway2, fig.wide=TRUE, fig.cap="The effect of adding a new pathway to a functional similarity. In red the same network as in black but with the added pathway.", warning=FALSE, message=FALSE}
library("Hmisc")
genesReact2 <- genesReact
diffGenes <- genes[genes$ENSEMBL %in% deg, "ENTREZID"]
# Create the new pathway called deg
genesReact2[diffGenes] <- sapply(genesReact[diffGenes], function(x){c(x, "deg")})
ids <- unique(genes[genes$ENSEMBL %in% rownames(subRes), "ENTREZID"])
Ecdf(c(mgeneSim(ids, genesReact, method = "BMA"),  
       mgeneSim(ids, genesReact2, method = "BMA")), 
     group = c(rep("Reactome", length(gS)), rep("Modified", length(gS))), 
     col = c("black", "red"), xlab = "Functional similarities", main = "Empirical cumulative distribution")
```

# Merging source of information

We can compare and evaluate what happens when we mix sources of pathways:
```{r combineSource, fig.cap = "Comparison of functional similarity in different databases."}
genesKegg <- as.list(org.Hs.egPATH)
gSK <- mgeneSim(rownames(gS), genesKegg)
mix <- combineSources(genesKegg, genesReact)
gSMix <- BioCor::mgeneSim(rownames(gS), mix)
Ecdf(c(gS, gSK, gSMix), 
     group = c(rep("Reactome", length(gS)), rep("Kegg", length(gSK)), 
               rep("Mix", length(gSMix))), 
     col = c("black", "red", "blue"), xlab = "Functional similarities", main = "ecdf")
```
When mixed, there is a huge increase in the genes that share a pathway.
```{r cominbeSource2, fig.cap = "Comparison of functional similarity in different gene sets."}
gSK2 <- BioCor::mgeneSim(rownames(gS), genesKegg, method = "BMA")
gS2 <- BioCor::mgeneSim(rownames(gS), genesReact, method = "BMA")
gSMix2 <- BioCor::mgeneSim(rownames(gS), mix, method = "BMA")
Ecdf(c(gS2, gSK2, gSMix2), 
     group = c(rep("Reactome", length(gS)), rep("Kegg", length(gSK)), 
               rep("Mix", length(gSMix))), 
     col = c("black", "red", "blue"), xlab = "Functional similarities (BMA)", main = "ecdf")
```
Now we can appreciate that most of the functional similarity is brought by Reactome database

# miRNA analysis

In this section we try to answer how functionally similar are two miRNA. This preparation has Been adapted from a [previous discussion](https://support.bioconductor.org/p/48138/#48236):
```{r miRNA1}
library("targetscan.Hs.eg.db")
## select human mirna 
humanMirnaIdx <- grep("hsa", mappedkeys(targetscan.Hs.egMIRNA)) 
## select seed-based families for human mirna
humanMirna <- mappedkeys(targetscan.Hs.egMIRNA)[humanMirnaIdx]
## select targets of families 
humanMirnaFamilies <- unlist(mget(humanMirna, targetscan.Hs.egMIRBASE2FAMILY)) 
humanMirnaTargets <- mget(humanMirnaFamilies, revmap(targetscan.Hs.egTARGETS))
names(humanMirnaTargets) <- humanMirna
# Restrict to miRNA with more than one target and less than 150
miRNAs <- sample(humanMirnaTargets[lengths(humanMirnaTargets) > 1 &
                                       lengths(humanMirnaTargets) < 150], 10)
lengths(miRNAs)
```
Now we have selected our miRNAs we can compare them using a cluster approach.
```{r miRNA2}
cluster1 <- BioCor::mclusterSim(miRNAs, genesReact, method = "BMA")
cluster1[1:10, 1:5]
```
So for instance `r m <- which(cluster1 == max(as.dist(cluster1)), arr.ind = TRUE); rownames(m)[m[, 1] != m[, 2]]` are functionally related despite being from different families. 

# Comparing with GO similarities

As suggested in the main vignette functional similarities can be compared to semantic similarities such as those based on GO. Here I will make a comparison using the biological process:

```{r GOSemSim, fig.wide = TRUE, fig.cap = "Comparison of similarities. Functional similarities compared to biological process semantic similarity."}
library("GOSemSim")
BP <- godata('org.Hs.eg.db', ont="BP", computeIC=TRUE)
gsGO <- GOSemSim::mgeneSim(rownames(gS), semData = BP, measure = "Resnik", verbose = FALSE)
keep <- rownames(gS) %in% rownames(gsGO)
hist(as.dist(gS[keep, keep]-gsGO), 
     main = "Difference between functional similarity and biological process", 
     xlab = "Functional similarity - biological process similarity")
```
As we can see in this example, genes with similar biological process tend to be on different functions. We can further compare with the different databases:

```{r GOSemSim2, fig.cap="Histogram of functional similarities minus biological process similarities"}
par(mfrow = c(1, 2))
hist(as.dist(gS2[keep, keep]-gsGO), main = "Reactome", 
     xlab = "Functional similarity - biological process similarity")
hist(as.dist(gSK2[keep, keep]-gsGO), main = "Kegg",
     xlab = "Functional similarity - biological process similarity")
```
Both databases show the same trend, the difference follow a beta distribution. 

# Session Info {.unnumbered}

```{r session}
sessionInfo()
```

